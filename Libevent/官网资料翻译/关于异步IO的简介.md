大部分人开始编程时都是基于阻塞IO。如果是阻塞IO，当你调用它时，直到内部操作全部完成，或者是达到了你设定的超时时间，才会返回。比如，当你在TCP连接时调用connect()，操作系统发送SYN包到连接的对端。直到你接收到一个SYN ACK包时，或者达到超时时间决定放弃本次操作，本次调用才会返回。

==========示例=========

上面的示例中，所有的网络调用都是阻塞的：gethostbyname(), connect(), recv(), send()。

现在，阻塞IO不是不可避免的噩梦。当前如果你不想程序做任何事情，阻塞IO会工作的很好。但是，我猜测你可能需要写一次性处理多个连接的程序。一个具体的示例：假定你需要从两个连接读取输入，但你不知道哪个连接的数据会先到达。

==========示例=========



有时人们会用多线程的方式解决这个问题，或者多进程。

还有一个例子，使用多进程的方式处理每个连接的输入，然后返回。

但是，我们有更完美的解决方案，来一次性处理多个连接吗？多进程或多线程是在某些平台上是有不小的开销的。

在类Unix系统里，你应该将socket设置为nonblocking：

```c
fcntl(fd, F_SETFL, O_NONBLOCK);
```



如果将多个连接的socket设置为非阻塞，然后不断遍历它们，这对CPU性能是个非常大的浪费。

同时，如果连接数量太多，但活跃的连接不多时，整体遍历的性能也是非常低的。



read(), write()都是系统调用，但可以换个思路：让内核通知用户何时在哪些连接的状态发生了改变。

旧的解决方式是select()， 其使用了3个事件集：读事件，写事件，异常事件。



但是，为select设置的最大文件描述符数量，对其性能有正比的影响；当数量太多时，其调用所花费的时间就越长；

而且，select在不同平台上的实现也不一致。



